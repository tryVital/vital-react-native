{"mappings":"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","sources":["./packages/@react-stately/combobox/src/useComboBoxState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, FocusStrategy, Node} from '@react-types/shared';\nimport {ComboBoxProps} from '@react-types/combobox';\nimport {ListCollection, useSingleSelectListState} from '@react-stately/list';\nimport {SelectState} from '@react-stately/select';\nimport {useControlledState} from '@react-stately/utils';\nimport {useEffect, useMemo, useRef, useState} from 'react';\nimport {useMenuTriggerState} from '@react-stately/menu';\n\nexport interface ComboBoxState<T> extends SelectState<T> {\n  /** The current value of the combo box input. */\n  inputValue: string,\n  /** Sets the value of the combo box input. */\n  setInputValue(value: string): void,\n  /** Selects the currently focused item and updates the input value. */\n  commit(): void\n}\n\ntype FilterFn = (textValue: string, inputValue: string) => boolean;\ninterface ComboBoxStateProps<T> extends ComboBoxProps<T> {\n  /** The filter function used to determine if a option should be included in the combo box list. */\n  defaultFilter?: FilterFn,\n  /** Whether the combo box allows the menu to be open when the collection is empty. */\n  allowsEmptyCollection?: boolean,\n  /** Whether the combo box menu should close on blur. */\n  shouldCloseOnBlur?: boolean\n}\n\n/**\n * Provides state management for a combo box component. Handles building a collection\n * of items from props and manages the option selection state of the combo box. In addition, it tracks the input value,\n * focus state, and other properties of the combo box.\n */\nexport function useComboBoxState<T extends object>(props: ComboBoxStateProps<T>): ComboBoxState<T> {\n  let {\n    defaultFilter,\n    menuTrigger = 'input',\n    allowsEmptyCollection = false,\n    allowsCustomValue,\n    shouldCloseOnBlur = true\n  } = props;\n\n  let [isFocused, setFocusedState] = useState(false);\n  let [inputValue, setInputValue] = useControlledState(\n    props.inputValue,\n    props.defaultInputValue ?? '',\n    props.onInputChange\n  );\n\n  let onSelectionChange = (key) => {\n    if (props.onSelectionChange) {\n      props.onSelectionChange(key);\n    }\n\n    // If open state or selectedKey is uncontrolled and key is the same, reset the inputValue and close the menu\n    // (scenario: user clicks on already selected option)\n    if (props.isOpen === undefined || props.selectedKey === undefined) {\n      if (key === selectedKey) {\n        resetInputValue();\n        triggerState.close();\n      }\n    }\n  };\n\n  let {collection, selectionManager, selectedKey, setSelectedKey, selectedItem, disabledKeys} = useSingleSelectListState({\n    ...props,\n    onSelectionChange,\n    items: props.items ?? props.defaultItems\n  });\n\n  let filteredCollection = useMemo(() => (\n    // No default filter if items are controlled.\n    props.items != null || !defaultFilter\n      ? collection\n      : filterCollection(collection, inputValue, defaultFilter)\n  ), [collection, inputValue, defaultFilter, props.items]);\n\n  let triggerState = useMenuTriggerState(props);\n  let open = (focusStrategy?: FocusStrategy) => {\n    // Prevent open operations from triggering if there is nothing to display\n    if (allowsEmptyCollection || filteredCollection.size > 0) {\n      triggerState.open(focusStrategy);\n    }\n  };\n\n  let toggle = (focusStrategy?: FocusStrategy) => {\n    // If the menu is closed and there is nothing to display, early return so toggle isn't called to prevent extraneous onOpenChange\n    if (!(allowsEmptyCollection || filteredCollection.size > 0) && !triggerState.isOpen) {\n      return;\n    }\n\n    triggerState.toggle(focusStrategy);\n  };\n\n  let lastValue = useRef(inputValue);\n  let resetInputValue = () => {\n    let itemText = collection.getItem(selectedKey)?.textValue ?? '';\n    lastValue.current = itemText;\n    setInputValue(itemText);\n  };\n\n  let isInitialRender = useRef(true);\n  let lastSelectedKey = useRef(props.selectedKey ?? props.defaultSelectedKey ?? null);\n  useEffect(() => {\n    // If open state or inputValue is uncontrolled, open and close automatically when the input value changes,\n    // the input is if focused, and there are items in the collection.\n    if (\n      isFocused &&\n      filteredCollection.size > 0 &&\n      !triggerState.isOpen &&\n      inputValue !== lastValue.current &&\n      menuTrigger !== 'manual' &&\n      (props.isOpen === undefined || props.inputValue === undefined)\n    ) {\n      open();\n    }\n\n    // Close the menu if the collection is empty and either open state or items are uncontrolled.\n    if (\n      !allowsEmptyCollection &&\n      triggerState.isOpen &&\n      filteredCollection.size === 0 &&\n      (props.isOpen === undefined || props.items === undefined)\n    ) {\n      triggerState.close();\n    }\n\n    // Close when an item is selected, if open state or selectedKey is uncontrolled.\n    if (\n      selectedKey != null &&\n      selectedKey !== lastSelectedKey.current &&\n      (props.isOpen === undefined || props.selectedKey === undefined)\n    ) {\n      triggerState.close();\n    }\n\n    // Clear focused key when input value changes.\n    if (inputValue !== lastValue.current) {\n      selectionManager.setFocusedKey(null);\n\n      // Set selectedKey to null when the user clears the input.\n      // If controlled, this is the application developer's responsibility.\n      if (inputValue === '' && (props.inputValue === undefined || props.selectedKey === undefined)) {\n        setSelectedKey(null);\n      }\n    }\n\n    // If it is the intial render and inputValue isn't controlled nor has an intial value, set input to match current selected key if any\n    if (isInitialRender.current && (props.inputValue === undefined && props.defaultInputValue === undefined)) {\n      resetInputValue();\n    }\n\n    // If the selectedKey changed, update the input value.\n    // Do nothing if both inputValue and selectedKey are controlled.\n    // In this case, it's the user's responsibility to update inputValue in onSelectionChange. In addition, we preserve the defaultInputValue\n    // on initial render, even if it doesn't match the selected item's text.\n    if (\n      selectedKey !== lastSelectedKey.current &&\n      (props.inputValue === undefined || props.selectedKey === undefined)\n    ) {\n      resetInputValue();\n    } else {\n      lastValue.current = inputValue;\n    }\n\n    isInitialRender.current = false;\n    lastSelectedKey.current = selectedKey;\n  });\n\n  useEffect(() => {\n    // Reset focused key when the menu closes\n    if (!triggerState.isOpen) {\n      selectionManager.setFocusedKey(null);\n    }\n  }, [triggerState.isOpen, selectionManager]);\n\n  let commitCustomValue = () => {\n    let shouldClose = false;\n    lastSelectedKey.current = null;\n    setSelectedKey(null);\n\n    // If previous key was already null, need to manually call onSelectionChange since it won't be triggered by a setSelectedKey call\n    // This allows the application to control whether or not to close the menu on custom value commit\n    if (selectedKey === null && props.onSelectionChange) {\n      props.onSelectionChange(null);\n    }\n\n    // Should close menu ourselves if component open state or selected key is uncontrolled and therefore won't be closed by a user defined event handler\n    shouldClose = props.isOpen == null || props.selectedKey === undefined;\n\n\n    // Close if no other event will be fired. Otherwise, allow the\n    // application to control this based on that event.\n    if (shouldClose) {\n      triggerState.close();\n    }\n  };\n\n  let commit = () => {\n    if (triggerState.isOpen && selectionManager.focusedKey != null) {\n      // Reset inputValue and close menu here if the selected key is already the focused key. Otherwise\n      // fire onSelectionChange to allow the application to control the closing.\n      if (selectedKey === selectionManager.focusedKey) {\n        resetInputValue();\n        triggerState.close();\n      } else {\n        setSelectedKey(selectionManager.focusedKey);\n      }\n    } else if (allowsCustomValue) {\n      commitCustomValue();\n    }\n  };\n\n  let setFocused = (isFocused: boolean) => {\n    if (isFocused) {\n      if (menuTrigger === 'focus') {\n        open();\n      }\n    } else if (shouldCloseOnBlur) {\n      let itemText = collection.getItem(selectedKey)?.textValue ?? '';\n      if (allowsCustomValue && inputValue !== itemText) {\n        commitCustomValue();\n      } else {\n        resetInputValue();\n        // Close menu if blurring away from the combobox\n        // Specifically handles case where user clicks away from the field\n        triggerState.close();\n      }\n    }\n\n    setFocusedState(isFocused);\n  };\n\n  return {\n    ...triggerState,\n    toggle,\n    open,\n    selectionManager,\n    selectedKey,\n    setSelectedKey,\n    disabledKeys,\n    isFocused,\n    setFocused,\n    selectedItem,\n    collection: filteredCollection,\n    inputValue,\n    setInputValue,\n    commit\n  };\n}\n\nfunction filterCollection<T extends object>(collection: Collection<Node<T>>, inputValue: string, filter: FilterFn): Collection<Node<T>> {\n  return new ListCollection(filterNodes(collection, inputValue, filter));\n}\n\nfunction filterNodes<T>(nodes: Iterable<Node<T>>, inputValue: string, filter: FilterFn): Iterable<Node<T>> {\n  let filteredNode = [];\n  for (let node of nodes) {\n    if (node.type === 'section' && node.hasChildNodes) {\n      let filtered = filterNodes(node.childNodes, inputValue, filter);\n      if ([...filtered].length > 0) {\n        filteredNode.push({...node, childNodes: filtered});\n      }\n    } else if (node.type !== 'section' && filter(node.textValue, inputValue)) {\n      filteredNode.push(node);\n    }\n  }\n  return filteredNode;\n}\n"],"names":["useComboBoxState","props","defaultFilter","menuTrigger","allowsEmptyCollection","allowsCustomValue","shouldCloseOnBlur","isFocused","setFocusedState","useState","inputValue","setInputValue","useControlledState","defaultInputValue","onInputChange","onSelectionChange","key","isOpen","undefined","selectedKey","resetInputValue","triggerState","close","collection","selectionManager","setSelectedKey","selectedItem","disabledKeys","useSingleSelectListState","items","defaultItems","filteredCollection","useMemo","filterCollection","useMenuTriggerState","open","focusStrategy","size","toggle","lastValue","useRef","itemText","getItem","textValue","current","isInitialRender","lastSelectedKey","defaultSelectedKey","useEffect","setFocusedKey","commitCustomValue","shouldClose","commit","focusedKey","setFocused","filter","ListCollection","filterNodes","nodes","filteredNode","node","type","hasChildNodes","filtered","childNodes","length","push"],"version":3,"file":"module.js.map"}